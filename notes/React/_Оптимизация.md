https://reactjs.org/docs/optimizing-performance.html

1. Не забываем на продакшене использовать **build**-сборку, а не develop.

2. **React.memo** - компонент высшего порядка. Если компонент возвращает одинаковый результат при одних и тех же входящих параметрах (т.е. не зависит от внешних данных), то можно просто переиспользовать предыдущий вариант 
отображения этого компонента с этими параметрами, не запуская его перерендер. Этот функционал и предоставляет React.memo. Входящие параметры проверяет поверхностно, но может принимать кастомную функцию для сравнения текущих 
и предыдущих параметров.

3. **React.PureComponent** - тоже что и React.memo, но для классовых компонентов (но в классовых, не забывай, можно использовать shouldComponentUpdate метод для аналогичного поведения)

4. **Хуки useMemo и useCallback** - хуки для мемоизации вычесления, или определения функции-коллбека

5. Не прокидывать в пропсы дочерним компонентам новосозданный объект/массив, по типу: `<HeavyComponent items={[1, 2, 3]} />`. Нужно либо мемоизировать, либо использовать константу вне родительского компонента

6. Следить за пропс-дриллингом, не прокидывать проп глубоко внихз, если он нуженн только в самом низу. Лучше брать их стора.

7. **DevTools Profiler** - инструмент для профайлинга.

8. Не скрывать "тяжелые"-react-элементы с помощью display: none, а предотвращать их построение в DOM-дереве. 

_p.s. Нужно считать, что рендер react-компонента это дорогая операция, и оптимизация заключается именно в том, чтобы минимизировать рендеры_