https://reactjs.org/docs/optimizing-performance.html

###Основные концепции:

1. Не забываем на продакшене использовать **build**-сборку, а не develop. Расширение для хрома может удобно показать какая сборка на сайте.

2. **React.memo** - компонент высшего порядка. Если компонент возвращает одинаковый результат при одних и тех же входящих параметрах (т.е. не зависит от внешних данных), то можно просто переиспользовать предыдущий вариант 
отображения этого компонента с этими параметрами, не запуская его перерендер. Этот функционал и предоставляет React.memo. Входящие параметры проверяет поверхностно, но может принимать кастомную функцию для сравнения текущих 
и предыдущих параметров.

3. **React.PureComponent** - тоже что и React.memo, но для классовых компонентов (но в классовых, не забывай, можно использовать shouldComponentUpdate метод для аналогичного поведения)

4. **Хуки useMemo и useCallback** - хуки для мемоизации вычесления, или определения функции-коллбека

5. Не прокидывать в пропсы дочерним компонентам новосозданный объект/массив, по типу: `<HeavyComponent items={[1, 2, 3]} />`. Нужно либо мемоизировать, либо использовать константу вне родительского компонента

6. Следить за пропс-дриллингом, не прокидывать проп глубоко внихз, если он нуженн только в самом низу. Лучше брать их стора.

7. **DevTools Profiler** - инструмент для профайлинга. Можно включить запись, и изучить поведение рендера react-компонентов. Подробнее в документации.

8. Не скрывать "тяжелые"-react-элементы с помощью display: none, а предотвращать их построение в DOM-дереве.

9. Если дочерний компонент просто выводит props.children, то эти children не будут осуществлять перерендер если этот дочерний перерендерится. Потому-что в таком случае он уже выводит готовые элементы, которые ему были 
переданы выше в children. Поэтому передача готового DOM-дерева в children (или любой другой проп), может помочь избежать рендер этих самых children, во время перерендера компонента которому мы их передали

10. Разбить итоговый бандл на чанки можно с помощью ленивой (динамической) подзагрузки компонентов через **lazy()** и **<Suspence />**. Совсем тяжелые компоненты, которые используются только в некоторых случаях, есть смысл для оптимизации
загружать именно так. Сайт будет подзагружать отдельные *.js файлы по надобности, в отличие от одного большого сразу. Например - если много страниц в роутинге, то не самые важные страницы можно подзагружать лениво.

_p.s. Нужно считать, что рендер react-компонента это дорогая операция, и оптимизация заключается именно в том, чтобы минимизировать рендеры_

